"""
Dependencies: six, csv
"""

import csv
import six; from six.moves import cPickle as pickle



"""
@param: projFile
	The project file generated by generateProjectFile.py
@param: userFile
	The corresponding use file generated by generateUserFile.py
@param: min_projects
	The minimum mount of projects per user for that users projects
	to be included in te time series dataset.
@return:
	Returns an empty time series dataset and key [[],[]] on failure or
	Returns a list in the format [[key],[timeSeries]] such that
	data[0][i] -> data[1][i]
"""
def buildTimeSeries(projFile, userFile, min_projects):
	############################Open Files#####################################
	try:
		print("BuildTimeSeries[1/5] Opening " + projFile + " and " + userFile + " for reading:")
		rawUserReader = open(userFile, "r")
		rawProjReader = open(projFile, "r")
		userReader = csv.DictReader(rawUserReader)
		projReader = csv.DictReader(rawProjReader)
	except:
		print("BuildTimeSeries[1/5] File failed to open for reading:")
		print("BuildTimeSeries[1/5] Exiting empty list [[],[]]:")
		return [[],[]]
	print("BuildTimeSeries[1/5] Files " + projFile + " and " + userFile + " open for reading:")
	############################Link Projects##################################
	print("BuildTimeSeries[2/5] Linking project to user ids:")
	userTable = {}
	for user in userReader:
		proj = next(projReader)
		try:
			userTable[user['user_id']].insert(0,[])
		except:
			userTable.update({user['user_id']:[[]]})
		finally:
			del proj['project_id']
			for key in proj.keys():
				userTable[user['user_id']][0].append(proj[key])
	print("BuildTimeSeries[2/5] Projects linked to user ids:")
	############################Remove Time Series#############################
	print("BuildTimeSeries[3/5] Removing time series with less than " + str(min_projects) + " projects:")
	formattedData = [[],[]]
	for user in userTable.keys():
		if len(userTable[user]) >= min_projects:
			formattedData[0].append(user)
			formattedData[1].append(userTable[user])
	print("BuildTimeSeries[3/5] Time series with less than " +str(min_projects) + " projects removed:")
	############################Close Files####################################
	print("BuildTimeSeries[4/5] Closing " + projFile + " and " + userFile +":")
	rawUserReader.close()
	rawProjReader.close()
	print("BuildTimeSeries[4/5] Files " + projFile + " and " + userFile + " closed:")
	############################Return Result##################################
	print("BuildTimeSeries[5/5] Returning time series dataset:")
	return formattedData






"""
@param: projFile
	The project file generated by generateProjectFile.py
@param: userFile
	The corresponding use file generated by generateUserFile.py
@param: min_projects
	The minimum mount of projects per user for that users projects
	to be included in te time series dataset.
@param: filter
	filters to only include that specific field in the time series
	ex. filterng for data_representation
@return:
	Returns an empty time series dataset and key [[],[]] on failure or
	Returns a list in the format [[key],[timeSeries]] such that
	data[0][i] -> data[1][i]
"""
def buildTimeSeriesWithFilter(projFile, userFile, min_projects,filter):
	############################Open Files#####################################
	try:
		print("BuildTimeSeries[1/5] Opening " + projFile + " and " + userFile + " for reading:")
		rawUserReader = open(userFile, "r")
		rawProjReader = open(projFile, "r")
		userReader = csv.DictReader(rawUserReader)
		projReader = csv.DictReader(rawProjReader)
	except:
		print("BuildTimeSeries[1/5] File failed to open for reading:")
		print("BuildTimeSeries[1/5] Exiting empty list [[],[]]:")
		return [[],[]]
	print("BuildTimeSeries[1/5] Files " + projFile + " and " + userFile + " open for reading:")
	############################Link Projects##################################
	print("BuildTimeSeries[2/5] Linking project to user ids:")
	userTable = {}
	for user in userReader:
		proj = next(projReader)
		try:
			userTable[user['user_id']].insert(0,[])
		except:
			userTable.update({user['user_id']:[[]]})
		finally:
			#del proj['project_id']
			userTable[user['user_id']][0].append(proj[filter])
	print("BuildTimeSeries[2/5] Projects linked to user ids:")
	############################Remove Time Series#############################
	print("BuildTimeSeries[3/5] Removing time series with less than " + str(min_projects) + " projects:")
	formattedData = [[],[]]
	for user in userTable.keys():
		if len(userTable[user]) >= min_projects:
			formattedData[0].append(user)
			formattedData[1].append(userTable[user])
	print("BuildTimeSeries[3/5] Time series with less than " +str(min_projects) + " projects removed:")
	############################Close Files####################################
	print("BuildTimeSeries[4/5] Closing " + projFile + " and " + userFile +":")
	rawUserReader.close()
	rawProjReader.close()
	print("BuildTimeSeries[4/5] Files " + projFile + " and " + userFile + " closed:")
	############################Return Result##################################
	print("BuildTimeSeries[5/5] Returning time series dataset:")
	return formattedData






def getTSStart(projFile, userFile, min_projects,userID):
	############################Open Files#####################################
	try:
		print("BuildTimeSeries[1/5] Opening " + projFile + " and " + userFile + " for reading:")
		rawUserReader = open(userFile, "r")
		rawProjReader = open(projFile, "r")
		userReader = csv.DictReader(rawUserReader)
		projReader = csv.DictReader(rawProjReader)
	except:
		print("BuildTimeSeries[1/5] File failed to open for reading:")
		print("BuildTimeSeries[1/5] Exiting empty list [[],[]]:")
		return [[],[]]
	print("BuildTimeSeries[1/5] Files " + projFile + " and " + userFile + " open for reading:")
	############################Link Projects##################################
	print("BuildTimeSeries[2/5] Linking project to user ids:")
	userTable = {}
	for user in userReader:
		proj = next(projReader)
		proj_id = proj['project_id']
		try:
			userTable[user['user_id']].insert(0,[])
		except:
			userTable.update({user['user_id']:[[]]})
		finally:
			del proj['project_id']
			userTable[user['user_id']][0].append(proj_id)


	print("BuildTimeSeries[2/5] Projects linked to user ids:")
	############################Remove Time Series#############################
	print("BuildTimeSeries[3/5] Removing time series with less than " + str(min_projects) + " projects:")
	formattedData = [[],[]]
	for user in userTable.keys():
		if len(userTable[user]) >= min_projects:
			formattedData[0].append(user)
			formattedData[1].append(userTable[user])
	print("BuildTimeSeries[3/5] Time series with less than " +str(min_projects) + " projects removed:")
	############################Close Files####################################
	print("BuildTimeSeries[4/5] Closing " + projFile + " and " + userFile +":")
	rawUserReader.close()
	rawProjReader.close()
	print("BuildTimeSeries[4/5] Files " + projFile + " and " + userFile + " closed:")
	############################Return Result##################################
	#print("BuildTimeSeries[5/5] Returning time series dataset:")
	#return formattedData
	for i in range(len(formattedData[0])):
		if str(formattedData[0][i]) in str(userID):
			print( formattedData[1][i][0:7])
			break





"""The following functions wrap the functionality
of cpickle to save or load the timeseries and its key"""
def saveTSKey(filename, timeSeries):
	with open(filename, 'wb') as f:
   		pickle.dump(timeSeries[0], f)
def loadTSKey(filename):
	f = open(filename, 'rb')
	key = pickle.load(f)
	return key
def saveTSData(filename, timeSeries):
	with open(filename, 'wb') as f:
   		pickle.dump(timeSeries[1], f)
def loadTSData(filename):
	f = open(filename, 'rb')
	data = pickle.load(f)
	return data






#getTSStart("ProcessedData/project_blocks.csv", "ProcessedData/projects.csv",7,401242)

#timeseriesDataset = buildTimeSeries("ProcessedData/project_blocks.csv", "ProcessedData/projects.csv",7)
timeseriesDataset = buildTimeSeriesWithFilter("ProcessedData/project_blocks.csv", "ProcessedData/projects.csv",1,"block_count")
#print("Time Series Dataset Contains " + str(len(timeseriesDataset[0])) + " time series")
saveTSData("TSDataset/data.txt",timeseriesDataset)
saveTSKey("TSDataset/key.txt",timeseriesDataset)
